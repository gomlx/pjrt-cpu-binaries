# Use Amazon Linux 2023 as the base image for glibc compatibility
FROM amazonlinux:2023


# --- Install Dependencies and Fix DNF Conflict ---
# Fix DNF package conflict (curl-minimal vs curl) with --allowerasing
# Install tools: git, tar, make, C++ toolchain headers, python, pip, xz, curl
RUN dnf update -y && \
    dnf install -y --allowerasing \
        git tar make gcc-c++ \
        python3 python3-pip python3-devel \
        curl xz

# --- Manual LLVM/Clang Installation ---
# Downloads a modern Clang from GitHub Releases and installs it to /opt/llvm
ARG LLVM_VERSION="21.1.7"
ARG LLVM_ARCHIVE_NAME="LLVM-${LLVM_VERSION}-Linux-X64.tar.xz"
ENV INSTALL_DIR="/opt/llvm21"
ENV LLVM_VERSION=21

RUN mkdir -p ${INSTALL_DIR} && \
	curl -'#' -L --fail "https://github.com/llvm/llvm-project/releases/download/llvmorg-${LLVM_VERSION}/${LLVM_ARCHIVE_NAME}" -o llvm_temp.tar.xz && \
    echo "Download complete. Extracting..." && \
    tar -xJf llvm_temp.tar.xz --strip-components=1 -C ${INSTALL_DIR} && \
    rm llvm_temp.tar.xz && \
    chmod +x ${INSTALL_DIR}/bin/*

# --- Environment Setup (Equivalent to shell exports) ---
# Set environment variables to point Bazel/XLA to the manually installed Clang
ENV LLVM_PATH="${INSTALL_DIR}"
ENV PATH="${INSTALL_DIR}/bin:$PATH"
ENV LDFLAGS="-L${INSTALL_DIR}/lib"
ENV CPPFLAGS="-I${INSTALL_DIR}/include"
ENV CC="${INSTALL_DIR}/bin/clang"
ENV CXX="${INSTALL_DIR}/bin/clang++"
ENV HERMETIC_PYTHON_VERSION="3.11"
ENV BUILD_DIR="/app"
WORKDIR ${BUILD_DIR}


# --- Python Dependencies ---
RUN pip3 install six numpy

# --- Bazelisk Installation ---
# Install Bazelisk, rename it to 'bazel', and place it in /usr/local/bin to be on the default PATH.
RUN curl -LO "https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64" && \
    chmod +x bazelisk-linux-amd64 && \
    mv bazelisk-linux-amd64 /usr/local/bin/bazel

RUN python3 --version

# --- Copy Project Files ---
# Assuming this Dockerfile is run from the root of the 'pjrt-cpu-binaries' repository
# This makes BUILDER_VERSION.txt and the build script available.
#
# Notice: since this also copies the Dockerfile, if you are developing on it,
# this busts the Docker cache.
COPY BUILDER_VERSION.txt ${BUILD_DIR}
COPY XLA_COMMIT_HASH.txt ${BUILD_DIR}

# --- Clone External Repository ---
# This checks out the XLA repository, including submodules.
RUN XLA_COMMIT_HASH="$(cat XLA_COMMIT_HASH.txt)" && \
	echo "Cloning XLA at commit hash ${XLA_COMMIT_HASH}" && \
	git clone --recursive https://github.com/openxla/xla xla && \
	cd xla && git checkout "${XLA_COMMIT_HASH}"

# --- Build Command ---
# Define the command to build the PJRT CPU plugin.
# This logic is extracted from the "Build PJRT C API CPU plugin" step in the YAML.
RUN BUILDER_VERSION="$(cat BUILDER_VERSION.txt)" && \
    PJRT_C_API_HEADER="./xla/xla/pjrt/c/pjrt_c_api.h" && \
    MAJOR=$(grep -E '#define PJRT_API_MAJOR' "${PJRT_C_API_HEADER}" | awk '{print $3}') && \
    MINOR=$(grep -E '#define PJRT_API_MINOR' "${PJRT_C_API_HEADER}" | awk '{print $3}') && \
    echo "Building PJRT CPU plugin for version ${MAJOR}.${MINOR} (to be used in go-xla as v${MAJOR}.${MINOR}.${BUILDER_VERSION})" && \
    \
    cd xla && \
    printf "\nConfiguring XLA build:\n" && \
    echo ./configure.py --backend CPU --os LINUX --host_compiler CLANG --clang_path "${INSTALL_DIR}/bin/clang" && \
    ./configure.py --backend CPU --os LINUX --host_compiler CLANG --clang_path "${INSTALL_DIR}/bin/clang" && \
    \
    printf "\nStarting XLA bazel build:\n" && \
    bazel build -c opt //xla/service/cpu:runtime_matmul && \
    bazel build -c opt //xla/pjrt/c:pjrt_c_api_cpu_plugin.so

# --- Packaging Command (This requires a final step outside of the Dockerfile) ---
# The final steps to rename and tar the file are best performed as a separate
# command after the image is built, by running a temporary container.

# Use /bin/bash as the entry point for interactive exploration/debugging
CMD ["/bin/bash"]
